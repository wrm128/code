ZigZag是一种用于的整数压缩的编码方法，其中ProtoBuf和Thrift均采用了这种小巧的数字压缩算法。

### 回顾原码、反码、补码

第一位表示符号，0为非负数，1为负数   
[+8] = [00001000]原 = [0000 1000]反 = [0000 1000]补  
[-8] = [10001000]原 = [1111 0111]反 = [1111 1000]补

### zigzag

在绝大多数情况下，我们使用到的都是小整数。比如，我们会记录一个用户的id、一本书的id、一个回复的数量等；就像1234、1024、100等。而我们在系统之间进行通讯的时候，往往又需要以整型（int）或长整型（long）为基本的传输类型，他们在大多数系统中，以4Bytes和8Bytes来表示。这样，为了传输一个整型（int）8，我们需要传输00000000_00000000_00000000_00001000 32个bits，除了最后4位是有价值的，其他全是基本无价值的0。太浪费啦！！！

那么zigzag做的就是压缩前导0的操作，可是负数(-1)10 = (11111111_11111111_11111111_11111111)补 怎么办呢？它的前面全是1？
zigzag给出了一个很巧的方法：我们之前讲补码讲过，补码的第一位是符号位，他阻碍了我们对于前导0的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位：

(-1)10  
= (11111111_11111111_11111111_11111111)补  
= (11111111_11111111_11111111_11111111)符号后移  

但是即使这样，也是很难压缩的，因为数字绝对值越小，他所含的前导1越多。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数：

(-1)10  
= (11111111_11111111_11111111_11111111)补  
= (11111111_11111111_11111111_11111111)符号后移  
= (00000000_00000000_00000000_00000001)zigzag  

而对于非负整数，同样的将符号位移动到最后，其他位往前挪一位，数据保持不变。
 
(1)10  
= (00000000_00000000_00000000_00000001)补  
= (00000000_00000000_00000000_00000010)符号后移  
= (00000000_00000000_00000000_00000010)zigzag  

这样一来就可以进行压缩了，我们将1转换成(00000000_00000000_00000000_00000010)zigzag这个以后，我们最好只需要发送2bits（10），或者发送8bits（00000010），把前面的0全部省掉。因为数据传输是以字节为单位，所以，我们最好保持8bits这样的单位。所以我们有几种做法：
 
- 我们可以额外增加一个字节，用来表示接下来有效的字节长度，比如：00000001_00000010,前8位表示接下来有1个字节需要传输，第二8位表示真正的数据。这种方式虽然能达到我们想要的效果，但是莫名的增加一个字节的额外浪费。有没有不浪费的办法呢？

- 字节自表示方法。zigzag引入了一个方法，将转化后的zigzag按照7个bit一组进行划分，然后用每个组的第高位（第8位）表示该数字信息是否结束，1表示还有信息，0表示高位已经没有信息

举个例来讲：  
(-1000)10  
= (11111111_11111111_11111100_00011000)补  
= (00000000_00000000_00000111_11001111)zigzag  
 
我们先按照七位一组的方式将上面的数字划开：  
(0000-0000000-0000000-0001111-1001111)zigzag  

1. 它跟(~0x7f)做与操作的结果，高位还有信息，所以，我们把低7位取出来，并在倒数第八位上补一个1(0x80)：11001111
 
2. 将这个数右移七位：(0000-0000000-0000000-0000000-0001111)zigzag
 
3. 再取出最后的七位，跟(~0x7f)做与操作，发现高位已经没有信息了（全是0），那么我们就将最后8位完整的取出来：00001111，并且跳出循环，终止算法；
 
4. 最终，我们就得到了两个字节的数据[11001111, 00001111]

本文实现了基本的zigzag算法并进行了简单测试：
![img](https://github.com/wrm128/exercises/blob/master/zigzag/test%20result.png)

【refer】http://blog.csdn.net/zgwangbo/article/details/51590186
